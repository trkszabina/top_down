import win32com.client as win32
from docx import Document
import shutil

def copy_paragraph_style(source_paragraph, target_paragraph):
    target_paragraph.style = source_paragraph.style
    target_paragraph.alignment = source_paragraph.alignment
    for source_run, target_run in zip(source_paragraph.runs, target_paragraph.runs):
        target_run.bold = source_run.bold
        target_run.italic = source_run.italic
        target_run.underline = source_run.underline
        target_run.font.size = source_run.font.size
        target_run.font.name = source_run.font.name
        target_run.font.color.rgb = source_run.font.color.rgb

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Perform find and replace in all paragraphs
        for paragraph in temp_doc.paragraphs:
            try:
                if find_str in paragraph.text:
                    # Create a new paragraph with the same text as the original
                    new_paragraph = temp_doc.add_paragraph(paragraph.text)

                    # Copy the style of the original paragraph to the new one
                    copy_paragraph_style(paragraph, new_paragraph)

                    # Replace the text in the new paragraph
                    new_paragraph.text = new_paragraph.text.replace(find_str, replace_str)

                    # Remove the original paragraph
                    p_element = paragraph._element
                    p_element.getparent().remove(p_element)

            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)

























import win32com.client as win32

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Loop through all the paragraphs in the document
        for paragraph in doc.Content.Paragraphs:
            try:
                if find_str in paragraph.Range.Text:
                    # Use the Find and Replace method of the Range object to replace the text
                    paragraph.Range.Find.Execute(find_str, False, False, False, False, False, True, 1, True, replace_str, 2)

            except Exception as e:
                 print("An error occurred:", str(e))

        # Save and close the modified document
        doc.Save()
        doc.Close()

        print("Success")
    except Exception as e:
        print("Error:", str(e))

# Example usage
file_path = r'C:\Users\szabi\my_document.docx'
find_str = 'new_string'
replace_str = 'change'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)






















from lxml import etree
from docx import Document
from docx.opc.constants import RELATIONSHIP_TYPE as RT
from docx.opc import part

def read_dotx_xml(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        xml_content = file.read()

    return etree.XML(xml_content)

def modify_template_content(xml_root, new_content):
    nsmap = xml_root.nsmap
    word_namespace = nsmap[None]

    for paragraph in xml_root.findall('.//w:p', namespaces=nsmap):
        para_id = paragraph.get(f'{{{word_namespace}}}paraid')
        text_id = paragraph.get(f'{{{word_namespace}}}textid')

        if para_id == "0428BC03" and text_id == "562F96C2":
            for text_element in paragraph.findall('.//w:t', namespaces=nsmap):
                if text_element.get(f'{{{word_namespace}}}id') == "009F7F80":
                    text_element.text = "This header has been changed"

# Replace 'template.dotx' with the path to your .dotx file
xml_root = read_dotx_xml('template.dotx')

# Modify the content with the specified IDs
modify_template_content(xml_root, new_content={
    "0428BC03": "This header has been changed",
    # Add more ID mappings as needed
})

# Save the modified XML back to the .dotx file
def save_dotx_xml(file_path, xml_root):
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(etree.tostring(xml_root, pretty_print=True, encoding='unicode'))

# Save the modified XML back to the .dotx file
save_dotx_xml('modified_template.dotx', xml_root)























import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element.get_or_add_permStart() is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)





















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element._element.get('rsidRPr') is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)





import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element._p.rPr is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)












import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in doc.Paragraphs if p.Range.Editors.Count > 0]

        # Perform find and replace in all paragraphs
        for paragraph in doc.Paragraphs:
            try:
                if paragraph in protected_paragraphs and find_str in paragraph.Range.Text:
                    paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)













import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in doc.Paragraphs if p.Range.Editors.Count > 0]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.Range.Text:
                    paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)
















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Perform find and replace in all paragraphs
        for paragraph in temp_doc.paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)























import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Remove protection
        doc.Unprotect(password)

        # Perform find and replace
        for paragraph in doc.Paragraphs:
            if find_str in paragraph.Range.Text:
                paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)

        # Protect the document again using the password and "No changes" restriction
        doc.Protect(Type=2, NoReset=1, Password=password)

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test.docx'
find_str = 'change'
replace_str = 'apple'
password = '1'
find_replace_protected(file_path, find_str, replace_str, password)







import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Remove protection
        doc.Unprotect(password)

        # Perform find and replace
        for paragraph in doc.Paragraphs:
            if find_str in paragraph.Range.Text:
                paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)

        # Protect the document again using the password and "No changes" restriction
        doc.Protect(Type=2, NoReset=1, Password=password)

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test.docx'
find_str = 'change'
replace_str = 'apple'
password = '1'
find_replace_protected(file_path, find_str, replace_str, password)




















<!DOCTYPE html>
<html>
  <head>
    <title>Auto-Reload Example</title>
    <script>
     var intervalId; // Variable to store the interval ID

      function startReload() {
        if (!intervalId) { // Check if intervalId is not set
          intervalId = setInterval(function() {
            location.reload();
          }, 5000);
        }
      }

      function stopReload() {
        clearInterval(intervalId);
        intervalId = null; // Reset intervalId
      }
    </script>
  </head>
  <body>
    <h1>Auto-Reload Example</h1>
    <p>The page will automatically reload every 5 seconds.</p>

    <button onclick="startReload()">Start Reloading</button>
    <button onclick="stopReload()">Stop Reloading</button>
  </body>
</html>









<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document from SharePoint</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromSharePoint("<SharePoint document URL>");

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>





<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromBase64(
          "data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,<base64-encoded-document>"
        );

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>






<!DOCTYPE html>
<html>
<head>
    <title>Word Editor Example</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
</head>
<body>
    <div id="word-editor-container"></div>

    <script type="text/javascript">
        Office.initialize = function () {
            createWordEditor();
        };

        function createWordEditor() {
            Word.run(function (context) {
                var doc = context.application.createDocument();
                doc.open();
                doc.setContainer('#word-editor-container');
                doc.close();

                return context.sync();
            })
            .catch(function (error) {
                console.log(error);
            });
        }
    </script>
</body>
</html>





const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const officegen = require('officegen');

const siteUrl = "https://your-sharepoint-site-url";
const username = "your-sharepoint-username";
const password = "your-sharepoint-password";

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = officegen('docx');

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            const newDoc = officegen('docx');
            newDoc.load(fileContent);
            mergedDoc.append(newDoc);
        }

        const outputStream = fs.createWriteStream('merged_document.docx');
        mergedDoc.generate(outputStream);
        outputStream.on('finish', function () {
            console.log('Merged document saved successfully');
        });

    } catch (error) {
        console.log("Error:", error);
    }
})();




const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const username = process.env.SHAREPOINT_USERNAME;
const password = process.env.SHAREPOINT_PASSWORD;

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            mergedDoc.load(fileContent);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();













const { sp } = require("@pnp/nodejs");
const path = require("path");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const clientId = "your-client-id";
const clientSecret = "your-client-secret";

const credentials = {
    clientId: clientId,
    clientSecret: clientSecret,
    tenantId: "your-tenant-id",
};

sp.setup({
    sp: {
        baseUrl: siteUrl,
        authentication: {
            type: "aadAppCredentials",
            creds: credentials,
        },
        headers: {
            "User-Agent": "My App",
        },
        options: {
            nodeClientOptions: {
                // Provide the path to the SSL certificate (PEM file) if needed
                agentOptions: {
                    ca: null,
                },
            },
        },
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const content = fs.readFileSync(document.FileRef, 'binary');
            mergedDoc.load(content);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();






import React, { Component } from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';
import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'shift + tab',
                focusNext: 'tab'
            }
        });

        this.tbName = new InputTextView(this.props.locale);
        this.tbName.placeholder = this.props.locale.t('Bookmark Name');
        this.saveButtonView = this._createButton(this.props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
        this.saveButtonView.type = this.props.locale.t('submit');
        this.cancelButtonView = this._createButton(this.props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

        this.tbName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-edit-tbName']
            }
        });

        this.setTemplate({
            tag: 'form',

            attributes: {
                class: ['ck-bookmark-edit'],
                tabIndex: '-1'
            },

            children: [
                this.tbName,
                this.saveButtonView,
                this.cancelButtonView
            ]
        });
    }

    componentDidMount() {
        super.componentDidMount();

        submitHandler({
            view: this
        });

        const childViews = [
            this.tbName,
            this.saveButtonView,
            this.cancelButtonView
        ];

        childViews.forEach(v => {
            this._focusables.add(v);
            this.focusTracker.add(v.element);
        });

        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [
                    className
                ]
            }
        });

        if (eventName) {
            button.delegate('execute').to(this, eventName);
        }

        return button;
    }

    render() {
        return (
            <form className="ck-bookmark-edit" tabIndex="-1">
                {this.tbName}
                {this.saveButtonView}
                {this.cancelButtonView}
            </form>
        );
    }
}

export default EditPopup;






















import React, { Component } from 'react';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import LabelView from '@ckeditor/ckeditor5-ui/src/label/labelview';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';

import pencilIcon from '@ckeditor/ckeditor5-core/theme/icons/pencil.svg';
import deleteIcon from '../../theme/icons/delete.svg';

class ViewPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();

        this.lblName = new LabelView(this.props.locale);
        this.editButtonView = this._createButton(this.props.locale.t('Edit'), pencilIcon, 'ck-bookmark-view-btnEdit', 'edit');
        this.deleteButtonView = this._createButton(this.props.locale.t('Delete'), deleteIcon, 'ck-bookmark-view-btnDelete', 'delete');

        this.lblName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-view-lblName']
            }
        });
    }

    componentDidMount() {
        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [className]
            }
        });

        button.delegate('execute').to(this, eventName);

        return button;
    }

    render() {
        return (
            <div className="ck-bookmark-view">
                {this.lblName.render()}
                {this.editButtonView.render()}
                {this.deleteButtonView.render()}
            </div>
        );
    }
}

export default ViewPopup;


















import React from 'react';
import Plugin from '@ckeditor/ckeditor5-core/src/plugin';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ClickObserver from '@ckeditor/ckeditor5-engine/src/view/observer/clickobserver';
import ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';
import clickOutsideHandler from '@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler';
import ViewPopup from './ui/viewpopup';
import EditPopup from './ui/editpopup';
import bookmarkIcon from '../theme/icons/bookmark.svg';

class BookmarkUI extends Plugin {
    componentDidMount() {
        const editor = this.props.editor;
        const t = editor.t;

        editor.ui.componentFactory.add('bookmark', locale => {
            const btn = new ButtonView(locale);
            btn.set({
                label: t('Bookmark'),
                withText: false,
                tooltip: true,
                icon: bookmarkIcon
            });

            const bookmarkCommand = editor.commands.get('insertBookmark');
            btn.bind('isEnabled').to(bookmarkCommand, 'isEnabled');
            btn.bind('isOn').to(bookmarkCommand, 'isBookmark');

            this.listenTo(btn, 'execute', () => {
                editor.execute('insertBookmark');
                this._showUI();
            });

            return btn;
        });

        this._balloon = editor.plugins.get(ContextualBalloon);

        this._editPopup = this._createEditPopup();
        this._viewPopup = this._createViewPopup();

        editor.editing.view.addObserver(ClickObserver);
        this._enableUserBalloonInteractions();
    }

    _createEditPopup() {
        const editor = this.props.editor;
        const editPopup = new EditPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        editPopup.tbName.bind('value').to(command, 'value');

        editPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        this.listenTo(editPopup, 'submit', () => {
            const bookmarkName = editPopup.tbName.element.value;
            editor.execute('insertBookmark', bookmarkName);
            this._hideUI();
        });

        this.listenTo(editPopup, 'cancel', () => {
            this._hideUI();
        });

        return editPopup;
    }

    _createViewPopup() {
        const editor = this.props.editor;
        const viewPopup = new ViewPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        viewPopup.lblName.bind('text').to(command, 'value');

        this.listenTo(viewPopup, 'edit', () => {
            this._balloon.remove(this._viewPopup);
            this._balloon.add({
                view: this._editPopup,
                position: this._getBalloonPositionData()
            });

            this._editPopup.tbName.select();
        });

        this.listenTo(viewPopup, 'delete', () => {
            this.editor.execute('deleteBookmark');
            this._hideUI();
        });

        viewPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        return viewPopup;
    }

    _enableUserBalloonInteractions() {
        const viewDocument = this.props.editor.editing.view.document;

        this.listenTo(viewDocument, 'click', () => {
            const elmBookmark = this._getSelectedBookmarkElement();
            if (elmBookmark) {
                this._showUI();
            }
        });

        clickOutsideHandler({
            emitter: this._editPopup,
            activator: () => this._balloon.visible
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            import React from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';

import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';

import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';

import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends React.Component {
  constructor(props) {
    super(props);

    this.keystrokes = new KeystrokeHandler();

    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: 'shift + tab',
        focusNext: 'tab'
      }
    });

    this.tbName = new InputTextView(props.locale);
    this.tbName.placeholder = props.locale.t('Bookmark Name');
    this.saveButtonView = this._createButton(props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
    this.saveButtonView.type = props.locale.t('submit');
    this.cancelButtonView = this._createButton(props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

    this.tbName.extendTemplate({
      attributes: {
        class: ['ck-bookmark-edit-tbName']
      }
    });

    this.setTemplate({
      tag: 'form',

      attributes: {
        class: ['ck-bookmark-edit'],
        tabindex: '-1'
      },

      children: [
        this.tbName,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }

  render() {
    super.render();

    submitHandler({
      view: this
    });

    const childViews = [
      this.tbName,
      this.saveButtonView,
      this.cancelButtonView
    ];

    childViews.forEach(v => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });

    this.keystrokes.listenTo(this.element);
  }

  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.props.locale);

    button.set({
      label,
      icon,
      tooltip: true
    });

    button.extendTemplate({
      attributes: {
        class: [
          className
        ]
      }
    });

    if (eventName) {
      button.delegate('execute').to(this, eventName);
    }

    return button;
  }
}

export default EditPopup;


