Sub CreateCheckboxList()
    Dim i As Integer
    Dim chkBox As Checkbox
    Dim yPos As Single

    ' Set the initial position for the checkboxes
    yPos = 50
    
    ' Loop to create checkboxes
    For i = 1 To 5
        ' Create a checkbox
        Set chkBox = ActiveDocument.Shapes.AddFormControl _
            (Type:=msoControlCheckBox, Left:=50, Top:=yPos, Width:=100, Height:=15).OLEFormat.Object
        
        ' Set checkbox properties
        With chkBox
            .Name = "CheckBox" & i
            .Caption = "Checkbox " & i
        End With
        
        ' Increase the vertical position for the next checkbox
        yPos = yPos + 25
    Next i
End Sub










Sub UpdateList()
    Dim doc As Document
    Dim cc As ContentControl
    Dim item As String
    
    ' Define the list of items
    Dim itemList As Variant
    
    ' Define the list of fruits and vegetables
    Dim fruits As String
    Dim vegetables As String
    
    ' Populate the lists
    fruits = "Apple" & vbCr & "Banana" & vbCr & "Orange" & vbCr & "Grapes"
    vegetables = "Carrot" & vbCr & "Broccoli" & vbCr & "Spinach" & vbCr & "Potato"
    
    ' Set itemList based on selection
    For Each cc In ActiveDocument.ContentControls
        If cc.Type = wdContentControlDropdownList Then
            If cc.Title = "List" Then
                If cc.Range.Text = "Fruits" Then
                    itemList = Split(fruits, vbCr)
                ElseIf cc.Range.Text = "Vegetables" Then
                    itemList = Split(vegetables, vbCr)
                End If
                
                ' Clear the existing items
                cc.DropdownListEntries.Clear
                ' Add the new list of items
                For Each item In itemList
                    cc.DropdownListEntries.Add item
                Next item
            End If
        End If
    Next cc
End Sub







Sub CreateCheckboxDropdown()
    Dim rngDV As Range
    Dim ws As Worksheet
    
    ' Define worksheet
    Set ws = ThisWorkbook.Sheets("Sheet1") ' Replace "Sheet1" with your sheet name
    
    ' Define range for second dropdown
    Set rngDV = ws.Range("B1") ' Change to your desired cell for second dropdown
    
    With rngDV.Validation
        .Delete
        .Add Type:=xlValidateList, AlertStyle:=xlValidAlertStop, Operator:= _
             xlBetween, Formula1:="=INDIRECT($A$1)"
        .IgnoreBlank = True
        .InCellDropdown = True
        .ShowInput = True
        .ShowError = True
    End With
End Sub






action
--> used to typeset various mathematical symbols and notations associated with actions and operations in algebra, group theory, and related fields of mathematics.

ams
--> provides support for many features defined by the American Mathematical Society (AMS) in their LaTeX packages
--> features included: amsmath, amssymbols, amstheorems, amsfonts, amsdelimiters, amsoperators, amsrelations, amsaccents, amsalphabets

amscd
--> is used for creating commutative diagrams in LaTeX documents
--> primary purpose of the amscd package is to provide an environment for creating commutative diagrams. It offers commands for specifying nodes, arrows, and labels within the diagram

base
--> base LaTeX package refers to the core set of files and functionalities that make up the LaTeX typesetting system
--> these files are essential for running LaTeX and include the core document classes, font packages, basic formatting commands, and other essential components

bbox 
--> it is not a specific package or command
--> it is a term used to refer to the bounding box of an element in a web page
--> the bounding box is a rectangular box that encloses a rendered mathematical expression or any other HTML element
(For example, when MathJax renders a mathematical expression, it calculates the dimensions of the bounding box that surrounds the expression. This information is used to position the expression correctly on the web page)

braket
-->provides support for typesetting various types of brackets commonly used in quantum mechanics and linear algebra
--> these brackets include angle brackets, square brackets, curly brackets, and more
--> the braket extension is separate from the LaTeX package of the same name and serves a similar purpose

boldsymbol
--> used to make symbols and characters within mathematical expressions appear in bold

bussproofs
--> provides a set of macros for typesetting proof trees in formal logic
--> it is useful for creating structured and well-formatted proof trees in various branches of logic, including propositional logic and predicate logic

cancel
--> provides a range of methods for placing diagonal lines through mathematical expressions to indicate that they have been canceled out, crossed out, or marked for deletion
--> this is commonly used in mathematics, physics, and engineering to show simplifications or cancellations in equations

cases
--> provides an environment for typesetting cases or conditions within a mathematical expression
--> this is especially useful for defining piecewise functions or expressing mathematical definitions that are defined conditionally

centernot
--> used to typeset a negation symbol with an adjustable horizontal placement, so that it appears centered over the symbol it negates. This is particularly useful for indicating that a certain condition or property does not hold

color
--> provides support for adding color to documents
--> it allows you to specify colors using various color models (RGB, CMYK, and others) and apply colors to text, backgrounds, borders, and other elements within your LaTeX document

colortbl
--> extends the capabilities of the standard tabular and array environments by adding support for coloring individual cells, rows, columns, and rules (lines) in tables
--> it provides a simple way to add color to tables, which can be particularly useful for emphasizing specific data or improving the visual appeal of tables in documents

empheq
--> provides additional features and environments for easily creating and customizing equations with emphasis on specific parts
--> the package is particularly useful for highlighting or boxing parts of equations to draw attention to them

enclose
--> provides commands for creating various styles of frames or enclosures around mathematical expressions or text
--> this can be useful for emphasizing or drawing attention to specific parts of a document

extpfeil
--> provides additional arrow styles and customization options for extensible arrows
--> it extends the functionality of the standard amsmath package, allowing for more versatile and customizable arrows in mathematical expressions

gensymb
--> provides a convenient way to access a variety of common symbols and units, particularly those used in scientific and technical writing

html
--> is used to generate HTML code from a LaTeX document
--> this can be useful if you want to convert your LaTeX document into a webpage

mathtools
--> provides additional features and tools for typesetting mathematical content
--> it is considered a must-have package for serious mathematical typesetting in LaTeX
--> builds upon the functionality provided by the amsmath package, adding even more tools for typesetting complex mathematical expressions

mhchem
--> used for typesetting chemical equations and chemical formulae

newcommand
--> is used to define custom commands or macros
--> these commands allow you to create shortcuts for frequently used or complex sequences of LaTeX code
--> this can save you time and make your document more readable and maintainable

physics
--> provides a set of convenient and user-friendly commands for typesetting physics equations and expressions
--> it's designed to simplify the process of writing complex mathematical expressions commonly used in physics

textcomp
--> provides access to a wide range of additional text symbols, accents, and characters that are not available by default in the standard LaTeX fonts

upgreek
--> provides a way to typeset Greek letters in an upright (non-italic) font style
--> this is particularly useful in contexts where you want to maintain a consistent font style, such as when using Greek letters for variables in mathematical formulas

verb
--> provides a way to typeset verbatim text, which means that the text is reproduced exactly as it appears, including spaces and special characters
--> this is useful when you want to display code, commands, or other text that shouldn't be interpreted as LaTeX commands





import docx

def read_all_tables(docx_file_path):
    doc = docx.Document(docx_file_path)
    all_tables = doc.tables
    return all_tables

def read_table_data(table):
    table_data = []
    for row in table.rows:
        row_data = [cell.text.strip() for cell in row.cells]
        table_data.append(row_data)
    return table_data

def save_data_to_docx(data, output_file_path):
    doc = docx.Document()

    for table_data in data:
        table = doc.add_table(rows=len(table_data), cols=len(table_data[0]))

        for i, row_data in enumerate(table_data):
            for j, cell_value in enumerate(row_data):
                table.cell(i, j).text = cell_value

    doc.save(output_file_path)

# Example usage
if __name__ == "__main__":
    input_file_path = r'C:\Users\szabi\test.docx'
    output_file_path = r'C:\Users\szabi\test12.docx'

    extracted_tables = read_all_tables(input_file_path)

    if extracted_tables:
        table_data_list = []
        for table in extracted_tables:
            table_data = read_table_data(table)
            table_data_list.append(table_data)

        save_data_to_docx(table_data_list, output_file_path)
        print("Data extracted and saved to a new Word document.")
    else:
        print("No tables found in the input document.")











import os
import win32com.client as win32

def search_and_set_bookmark(doc_path, search_text, bookmark_name):
    # Create an instance of the Word application
    word_app = win32.Dispatch('Word.Application')

    try:
        # Open the Word document
        doc = word_app.Documents.Open(doc_path)
        found_text = False

        # Loop through all the paragraphs in the document
        for para in doc.Paragraphs:
            if search_text in para.Range.Text:
                found_text = True
                para.Range.Bookmarks.Add(bookmark_name)
                break

        if found_text:
            print(f"Bookmark '{bookmark_name}' set for the text: '{search_text}'")
        else:
            print(f"Text '{search_text}' not found in the document")

        # Save and close the document
        doc.Save()
        doc.Close()
    except Exception as e:
        print(f"Error: {e}")
    finally:
        # Quit Word application
        word_app.Quit()

def main():
    # Replace 'your_file.docx' with the path to your Word document
    doc_path = r'C:\Users\szabi\bookmark.docx'
    search_text = "Also here"  # Replace this with the text you want to find
    bookmark_name = "MyBookmark2"       # Replace this with the desired bookmark name

    if os.path.exists(doc_path):
        search_and_set_bookmark(doc_path, search_text, bookmark_name)
    else:
        print("The specified file does not exist.")

if __name__ == "__main__":
    main()

















import docx

def search_and_set_bookmark(doc, search_text, bookmark_name):
    found_text = False
    for paragraph in doc.paragraphs:
        if search_text in paragraph.text:
            found_text = True
            bookmark_range = paragraph.runs[0].add_bookmark(bookmark_name)
            break

    return found_text

def main():
    # Replace 'your_file.docx' with the path to your Word document
    docx_path = 'your_file.docx'
    search_text = "YOUR_SPECIFIC_TEXT"  # Replace this with the text you want to find
    bookmark_name = "MyBookmark"       # Replace this with the desired bookmark name

    doc = docx.Document(docx_path)
    found = search_and_set_bookmark(doc, search_text, bookmark_name)

    if found:
        print(f"Bookmark '{bookmark_name}' set for the text: '{search_text}'")
    else:
        print(f"Text '{search_text}' not found in the document")

    # Save the document with the bookmarks
    doc.save(docx_path)

if __name__ == "__main__":
    main()
















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Find and replace only in paragraphs within the bookmark "protected"
        for paragraph in temp_doc.paragraphs:
            try:
                if "protected" in paragraph._element.xml:
                    if find_str in paragraph.text:
                        paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)













import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Find and replace only in paragraphs within the bookmark "protected"
        for paragraph in temp_doc.paragraphs:
            try:
                if "protected" in paragraph._element.xml:
                    if find_str in paragraph.text:
                        paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)





















import win32com.client as win32
from docx import Document
import shutil
import os

def copy_bookmarks(source, destination):
    for bookmark in source.element.xpath('//w:bookmarkStart'):
        id_ = bookmark.get('{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id')
        end = bookmark.getparent().xpath('.//w:bookmarkEnd[@{http://schemas.openxmlformats.org/officeDocument/2006/relationships}id="%s"]' % id_)[0]
        destination.element.append(bookmark)
        destination.element.append(end)

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Find and replace only in paragraphs within the bookmark "protected"
        for paragraph in temp_doc.paragraphs:
            try:
                if "protected" in paragraph._element.xml:
                    if find_str in paragraph.text:
                        # Replace the text within the paragraph
                        paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Open the modified document with pywin32
        modified_doc = word.Documents.Open(FileName=temp_file_path, PasswordDocument=password)

        # Copy bookmarks from the original document to the modified document
        copy_bookmarks(doc, modified_doc)

        # Close the modified document
        modified_doc.Close()

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)




















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Perform find and replace in all paragraphs
        for paragraph in temp_doc.paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

        # Update the table of contents
        update_toc(file_path, password)

    except Exception as e:
        print("An error occurred:", str(e))

def update_toc(file_path, password):
    # Open Word application using pywin32
    word = win32.Dispatch("Word.Application")
    word.Visible = False

    # Open the protected document with pywin32 using the password
    doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

    # Update the table of contents
    doc.TablesOfContents(1).Update()

    # Save and close the document
    doc.Save()
    doc.Close()

    print("Table of Contents updated successfully!")

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)






















import win32com.client as win32
from docx import Document
import shutil

def copy_paragraph_style(source_paragraph, target_paragraph):
    target_paragraph.style = source_paragraph.style
    target_paragraph.alignment = source_paragraph.alignment
    for source_run, target_run in zip(source_paragraph.runs, target_paragraph.runs):
        target_run.bold = source_run.bold
        target_run.italic = source_run.italic
        target_run.underline = source_run.underline
        target_run.font.size = source_run.font.size
        target_run.font.name = source_run.font.name
        target_run.font.color.rgb = source_run.font.color.rgb

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Perform find and replace in all paragraphs
        for paragraph in temp_doc.paragraphs:
            try:
                if find_str in paragraph.text:
                    # Create a new paragraph with the same text as the original
                    new_paragraph = temp_doc.add_paragraph(paragraph.text)

                    # Copy the style of the original paragraph to the new one
                    copy_paragraph_style(paragraph, new_paragraph)

                    # Replace the text in the new paragraph
                    new_paragraph.text = new_paragraph.text.replace(find_str, replace_str)

                    # Remove the original paragraph
                    p_element = paragraph._element
                    p_element.getparent().remove(p_element)

            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)

























import win32com.client as win32

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Loop through all the paragraphs in the document
        for paragraph in doc.Content.Paragraphs:
            try:
                if find_str in paragraph.Range.Text:
                    # Use the Find and Replace method of the Range object to replace the text
                    paragraph.Range.Find.Execute(find_str, False, False, False, False, False, True, 1, True, replace_str, 2)

            except Exception as e:
                 print("An error occurred:", str(e))

        # Save and close the modified document
        doc.Save()
        doc.Close()

        print("Success")
    except Exception as e:
        print("Error:", str(e))

# Example usage
file_path = r'C:\Users\szabi\my_document.docx'
find_str = 'new_string'
replace_str = 'change'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)






















from lxml import etree
from docx import Document
from docx.opc.constants import RELATIONSHIP_TYPE as RT
from docx.opc import part

def read_dotx_xml(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        xml_content = file.read()

    return etree.XML(xml_content)

def modify_template_content(xml_root, new_content):
    nsmap = xml_root.nsmap
    word_namespace = nsmap[None]

    for paragraph in xml_root.findall('.//w:p', namespaces=nsmap):
        para_id = paragraph.get(f'{{{word_namespace}}}paraid')
        text_id = paragraph.get(f'{{{word_namespace}}}textid')

        if para_id == "0428BC03" and text_id == "562F96C2":
            for text_element in paragraph.findall('.//w:t', namespaces=nsmap):
                if text_element.get(f'{{{word_namespace}}}id') == "009F7F80":
                    text_element.text = "This header has been changed"

# Replace 'template.dotx' with the path to your .dotx file
xml_root = read_dotx_xml('template.dotx')

# Modify the content with the specified IDs
modify_template_content(xml_root, new_content={
    "0428BC03": "This header has been changed",
    # Add more ID mappings as needed
})

# Save the modified XML back to the .dotx file
def save_dotx_xml(file_path, xml_root):
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(etree.tostring(xml_root, pretty_print=True, encoding='unicode'))

# Save the modified XML back to the .dotx file
save_dotx_xml('modified_template.dotx', xml_root)























import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element.get_or_add_permStart() is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)





















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element._element.get('rsidRPr') is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)





import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in temp_doc.paragraphs if p._element._p.rPr is not None]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)












import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in doc.Paragraphs if p.Range.Editors.Count > 0]

        # Perform find and replace in all paragraphs
        for paragraph in doc.Paragraphs:
            try:
                if paragraph in protected_paragraphs and find_str in paragraph.Range.Text:
                    paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)













import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Get all the paragraphs with "No changes" protection
        protected_paragraphs = [p for p in doc.Paragraphs if p.Range.Editors.Count > 0]

        # Perform find and replace in the protected paragraphs
        for paragraph in protected_paragraphs:
            try:
                if find_str in paragraph.Range.Text:
                    paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'protected'
replace_str = 'changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)
















import win32com.client as win32
from docx import Document
import shutil

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Save a copy of the original document with the same protection settings
        temp_file_path = file_path.replace('.docx', '_temp.docx')
        shutil.copyfile(file_path, temp_file_path)

        # Close the original document
        doc.Close()

        # Open the temporary copy of the document with docx library
        temp_doc = Document(temp_file_path)

        # Perform find and replace in all paragraphs
        for paragraph in temp_doc.paragraphs:
            try:
                if find_str in paragraph.text:
                    paragraph.text = paragraph.text.replace(find_str, replace_str)
            except Exception as e:
                print(f"An error occurred while processing paragraph: {str(e)}")

        # Save the modified document
        temp_doc.save(temp_file_path)

        # Replace the original document with the updated one
        shutil.move(temp_file_path, file_path)

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test_document.docx'
find_str = 'Header'
replace_str = 'The header has been changed'
password = 'apple'
find_replace_protected(file_path, find_str, replace_str, password)























import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Remove protection
        doc.Unprotect(password)

        # Perform find and replace
        for paragraph in doc.Paragraphs:
            if find_str in paragraph.Range.Text:
                paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)

        # Protect the document again using the password and "No changes" restriction
        doc.Protect(Type=2, NoReset=1, Password=password)

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test.docx'
find_str = 'change'
replace_str = 'apple'
password = '1'
find_replace_protected(file_path, find_str, replace_str, password)







import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Remove protection
        doc.Unprotect(password)

        # Perform find and replace
        for paragraph in doc.Paragraphs:
            if find_str in paragraph.Range.Text:
                paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)

        # Protect the document again using the password and "No changes" restriction
        doc.Protect(Type=2, NoReset=1, Password=password)

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test.docx'
find_str = 'change'
replace_str = 'apple'
password = '1'
find_replace_protected(file_path, find_str, replace_str, password)




















<!DOCTYPE html>
<html>
  <head>
    <title>Auto-Reload Example</title>
    <script>
     var intervalId; // Variable to store the interval ID

      function startReload() {
        if (!intervalId) { // Check if intervalId is not set
          intervalId = setInterval(function() {
            location.reload();
          }, 5000);
        }
      }

      function stopReload() {
        clearInterval(intervalId);
        intervalId = null; // Reset intervalId
      }
    </script>
  </head>
  <body>
    <h1>Auto-Reload Example</h1>
    <p>The page will automatically reload every 5 seconds.</p>

    <button onclick="startReload()">Start Reloading</button>
    <button onclick="stopReload()">Stop Reloading</button>
  </body>
</html>









<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document from SharePoint</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromSharePoint("<SharePoint document URL>");

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>





<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromBase64(
          "data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,<base64-encoded-document>"
        );

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>






<!DOCTYPE html>
<html>
<head>
    <title>Word Editor Example</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
</head>
<body>
    <div id="word-editor-container"></div>

    <script type="text/javascript">
        Office.initialize = function () {
            createWordEditor();
        };

        function createWordEditor() {
            Word.run(function (context) {
                var doc = context.application.createDocument();
                doc.open();
                doc.setContainer('#word-editor-container');
                doc.close();

                return context.sync();
            })
            .catch(function (error) {
                console.log(error);
            });
        }
    </script>
</body>
</html>





const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const officegen = require('officegen');

const siteUrl = "https://your-sharepoint-site-url";
const username = "your-sharepoint-username";
const password = "your-sharepoint-password";

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = officegen('docx');

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            const newDoc = officegen('docx');
            newDoc.load(fileContent);
            mergedDoc.append(newDoc);
        }

        const outputStream = fs.createWriteStream('merged_document.docx');
        mergedDoc.generate(outputStream);
        outputStream.on('finish', function () {
            console.log('Merged document saved successfully');
        });

    } catch (error) {
        console.log("Error:", error);
    }
})();




const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const username = process.env.SHAREPOINT_USERNAME;
const password = process.env.SHAREPOINT_PASSWORD;

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            mergedDoc.load(fileContent);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();













const { sp } = require("@pnp/nodejs");
const path = require("path");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const clientId = "your-client-id";
const clientSecret = "your-client-secret";

const credentials = {
    clientId: clientId,
    clientSecret: clientSecret,
    tenantId: "your-tenant-id",
};

sp.setup({
    sp: {
        baseUrl: siteUrl,
        authentication: {
            type: "aadAppCredentials",
            creds: credentials,
        },
        headers: {
            "User-Agent": "My App",
        },
        options: {
            nodeClientOptions: {
                // Provide the path to the SSL certificate (PEM file) if needed
                agentOptions: {
                    ca: null,
                },
            },
        },
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const content = fs.readFileSync(document.FileRef, 'binary');
            mergedDoc.load(content);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();






import React, { Component } from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';
import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'shift + tab',
                focusNext: 'tab'
            }
        });

        this.tbName = new InputTextView(this.props.locale);
        this.tbName.placeholder = this.props.locale.t('Bookmark Name');
        this.saveButtonView = this._createButton(this.props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
        this.saveButtonView.type = this.props.locale.t('submit');
        this.cancelButtonView = this._createButton(this.props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

        this.tbName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-edit-tbName']
            }
        });

        this.setTemplate({
            tag: 'form',

            attributes: {
                class: ['ck-bookmark-edit'],
                tabIndex: '-1'
            },

            children: [
                this.tbName,
                this.saveButtonView,
                this.cancelButtonView
            ]
        });
    }

    componentDidMount() {
        super.componentDidMount();

        submitHandler({
            view: this
        });

        const childViews = [
            this.tbName,
            this.saveButtonView,
            this.cancelButtonView
        ];

        childViews.forEach(v => {
            this._focusables.add(v);
            this.focusTracker.add(v.element);
        });

        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [
                    className
                ]
            }
        });

        if (eventName) {
            button.delegate('execute').to(this, eventName);
        }

        return button;
    }

    render() {
        return (
            <form className="ck-bookmark-edit" tabIndex="-1">
                {this.tbName}
                {this.saveButtonView}
                {this.cancelButtonView}
            </form>
        );
    }
}

export default EditPopup;






















import React, { Component } from 'react';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import LabelView from '@ckeditor/ckeditor5-ui/src/label/labelview';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';

import pencilIcon from '@ckeditor/ckeditor5-core/theme/icons/pencil.svg';
import deleteIcon from '../../theme/icons/delete.svg';

class ViewPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();

        this.lblName = new LabelView(this.props.locale);
        this.editButtonView = this._createButton(this.props.locale.t('Edit'), pencilIcon, 'ck-bookmark-view-btnEdit', 'edit');
        this.deleteButtonView = this._createButton(this.props.locale.t('Delete'), deleteIcon, 'ck-bookmark-view-btnDelete', 'delete');

        this.lblName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-view-lblName']
            }
        });
    }

    componentDidMount() {
        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [className]
            }
        });

        button.delegate('execute').to(this, eventName);

        return button;
    }

    render() {
        return (
            <div className="ck-bookmark-view">
                {this.lblName.render()}
                {this.editButtonView.render()}
                {this.deleteButtonView.render()}
            </div>
        );
    }
}

export default ViewPopup;


















import React from 'react';
import Plugin from '@ckeditor/ckeditor5-core/src/plugin';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ClickObserver from '@ckeditor/ckeditor5-engine/src/view/observer/clickobserver';
import ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';
import clickOutsideHandler from '@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler';
import ViewPopup from './ui/viewpopup';
import EditPopup from './ui/editpopup';
import bookmarkIcon from '../theme/icons/bookmark.svg';

class BookmarkUI extends Plugin {
    componentDidMount() {
        const editor = this.props.editor;
        const t = editor.t;

        editor.ui.componentFactory.add('bookmark', locale => {
            const btn = new ButtonView(locale);
            btn.set({
                label: t('Bookmark'),
                withText: false,
                tooltip: true,
                icon: bookmarkIcon
            });

            const bookmarkCommand = editor.commands.get('insertBookmark');
            btn.bind('isEnabled').to(bookmarkCommand, 'isEnabled');
            btn.bind('isOn').to(bookmarkCommand, 'isBookmark');

            this.listenTo(btn, 'execute', () => {
                editor.execute('insertBookmark');
                this._showUI();
            });

            return btn;
        });

        this._balloon = editor.plugins.get(ContextualBalloon);

        this._editPopup = this._createEditPopup();
        this._viewPopup = this._createViewPopup();

        editor.editing.view.addObserver(ClickObserver);
        this._enableUserBalloonInteractions();
    }

    _createEditPopup() {
        const editor = this.props.editor;
        const editPopup = new EditPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        editPopup.tbName.bind('value').to(command, 'value');

        editPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        this.listenTo(editPopup, 'submit', () => {
            const bookmarkName = editPopup.tbName.element.value;
            editor.execute('insertBookmark', bookmarkName);
            this._hideUI();
        });

        this.listenTo(editPopup, 'cancel', () => {
            this._hideUI();
        });

        return editPopup;
    }

    _createViewPopup() {
        const editor = this.props.editor;
        const viewPopup = new ViewPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        viewPopup.lblName.bind('text').to(command, 'value');

        this.listenTo(viewPopup, 'edit', () => {
            this._balloon.remove(this._viewPopup);
            this._balloon.add({
                view: this._editPopup,
                position: this._getBalloonPositionData()
            });

            this._editPopup.tbName.select();
        });

        this.listenTo(viewPopup, 'delete', () => {
            this.editor.execute('deleteBookmark');
            this._hideUI();
        });

        viewPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        return viewPopup;
    }

    _enableUserBalloonInteractions() {
        const viewDocument = this.props.editor.editing.view.document;

        this.listenTo(viewDocument, 'click', () => {
            const elmBookmark = this._getSelectedBookmarkElement();
            if (elmBookmark) {
                this._showUI();
            }
        });

        clickOutsideHandler({
            emitter: this._editPopup,
            activator: () => this._balloon.visible
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            import React from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';

import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';

import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';

import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends React.Component {
  constructor(props) {
    super(props);

    this.keystrokes = new KeystrokeHandler();

    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: 'shift + tab',
        focusNext: 'tab'
      }
    });

    this.tbName = new InputTextView(props.locale);
    this.tbName.placeholder = props.locale.t('Bookmark Name');
    this.saveButtonView = this._createButton(props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
    this.saveButtonView.type = props.locale.t('submit');
    this.cancelButtonView = this._createButton(props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

    this.tbName.extendTemplate({
      attributes: {
        class: ['ck-bookmark-edit-tbName']
      }
    });

    this.setTemplate({
      tag: 'form',

      attributes: {
        class: ['ck-bookmark-edit'],
        tabindex: '-1'
      },

      children: [
        this.tbName,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }

  render() {
    super.render();

    submitHandler({
      view: this
    });

    const childViews = [
      this.tbName,
      this.saveButtonView,
      this.cancelButtonView
    ];

    childViews.forEach(v => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });

    this.keystrokes.listenTo(this.element);
  }

  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.props.locale);

    button.set({
      label,
      icon,
      tooltip: true
    });

    button.extendTemplate({
      attributes: {
        class: [
          className
        ]
      }
    });

    if (eventName) {
      button.delegate('execute').to(this, eventName);
    }

    return button;
  }
}

export default EditPopup;


