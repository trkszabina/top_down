import win32com.client as win32
from docx import Document

def find_replace_protected(file_path, find_str, replace_str, password):
    try:
        # Open Word application using pywin32
        word = win32.Dispatch("Word.Application")
        word.Visible = False

        # Open the protected document with pywin32 using the password
        doc = word.Documents.Open(FileName=file_path, PasswordDocument=password)

        # Remove protection
        doc.Unprotect(password)

        # Perform find and replace
        for paragraph in doc.Paragraphs:
            if find_str in paragraph.Range.Text:
                paragraph.Range.Text = paragraph.Range.Text.replace(find_str, replace_str)

        # Protect the document again using the password and "No changes" restriction
        doc.Protect(Type=2, NoReset=1, Password=password)

        # Save the modified document
        doc.Save()

        # Close the document and quit Word application
        doc.Close()
        word.Quit()

        print("Find and replace completed successfully!")

    except Exception as e:
        print("An error occurred:", str(e))

# Example usage
file_path = r'C:\Users\szabi\test.docx'
find_str = 'change'
replace_str = 'apple'
password = '1'
find_replace_protected(file_path, find_str, replace_str, password)




















<!DOCTYPE html>
<html>
  <head>
    <title>Auto-Reload Example</title>
    <script>
     var intervalId; // Variable to store the interval ID

      function startReload() {
        if (!intervalId) { // Check if intervalId is not set
          intervalId = setInterval(function() {
            location.reload();
          }, 5000);
        }
      }

      function stopReload() {
        clearInterval(intervalId);
        intervalId = null; // Reset intervalId
      }
    </script>
  </head>
  <body>
    <h1>Auto-Reload Example</h1>
    <p>The page will automatically reload every 5 seconds.</p>

    <button onclick="startReload()">Start Reloading</button>
    <button onclick="stopReload()">Stop Reloading</button>
  </body>
</html>









<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document from SharePoint</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromSharePoint("<SharePoint document URL>");

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>





<!DOCTYPE html>
<html>
<head>
  <title>Embedding Word Document</title>
  <script src="https://appsforoffice.microsoft.com/lib/1/hosted/Office.js"></script>
</head>
<body>
  <div id="word-container"></div>

  <script>
    Office.initialize = function () {
      Word.run(function (context) {
        var doc = context.document;
        var contentControl = doc.body.insertContentControl();
        contentControl.insertFileFromBase64(
          "data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,<base64-encoded-document>"
        );

        return context.sync();
      }).catch(function (error) {
        console.error(error);
      });
    };
  </script>
</body>
</html>






<!DOCTYPE html>
<html>
<head>
    <title>Word Editor Example</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js" type="text/javascript"></script>
</head>
<body>
    <div id="word-editor-container"></div>

    <script type="text/javascript">
        Office.initialize = function () {
            createWordEditor();
        };

        function createWordEditor() {
            Word.run(function (context) {
                var doc = context.application.createDocument();
                doc.open();
                doc.setContainer('#word-editor-container');
                doc.close();

                return context.sync();
            })
            .catch(function (error) {
                console.log(error);
            });
        }
    </script>
</body>
</html>





const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const officegen = require('officegen');

const siteUrl = "https://your-sharepoint-site-url";
const username = "your-sharepoint-username";
const password = "your-sharepoint-password";

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = officegen('docx');

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            const newDoc = officegen('docx');
            newDoc.load(fileContent);
            mergedDoc.append(newDoc);
        }

        const outputStream = fs.createWriteStream('merged_document.docx');
        mergedDoc.generate(outputStream);
        outputStream.on('finish', function () {
            console.log('Merged document saved successfully');
        });

    } catch (error) {
        console.log("Error:", error);
    }
})();




const { sp } = require("@pnp/sp");
require("@pnp/sp/webs");
require("@pnp/sp/lists");
require("@pnp/sp/files");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const username = process.env.SHAREPOINT_USERNAME;
const password = process.env.SHAREPOINT_PASSWORD;

sp.setup({
    sp: {
        baseUrl: siteUrl,
        fetchClientFactory: () => new sp.FetchClientFactory(siteUrl, username, password),
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const fileUrl = `${siteUrl}/${document.FileRef}`;
            const fileContent = await sp.web.getFileByServerRelativeUrl(fileUrl).getBuffer();

            mergedDoc.load(fileContent);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();













const { sp } = require("@pnp/nodejs");
const path = require("path");
const fs = require('fs');
const Docxtemplater = require('docxtemplater');

const siteUrl = "https://your-sharepoint-site-url";
const clientId = "your-client-id";
const clientSecret = "your-client-secret";

const credentials = {
    clientId: clientId,
    clientSecret: clientSecret,
    tenantId: "your-tenant-id",
};

sp.setup({
    sp: {
        baseUrl: siteUrl,
        authentication: {
            type: "aadAppCredentials",
            creds: credentials,
        },
        headers: {
            "User-Agent": "My App",
        },
        options: {
            nodeClientOptions: {
                // Provide the path to the SSL certificate (PEM file) if needed
                agentOptions: {
                    ca: null,
                },
            },
        },
    },
});

const libraryName = "Documents";
const queryParameters = {
    Top: 10,  // Number of documents to fetch (e.g., 10)
    OrderBy: "Created desc"  // Sort documents by creation date in descending order
};

(async () => {
    try {
        const documents = await sp.web.lists.getByTitle(libraryName).items.select("FileLeafRef", "FileRef").top(queryParameters.Top).orderBy(queryParameters.OrderBy).get();

        const mergedDoc = new Docxtemplater();

        // Iterate through the documents
        for (const document of documents) {
            const content = fs.readFileSync(document.FileRef, 'binary');
            mergedDoc.load(content);

            // Add a page break between merged documents
            const pageBreak = new Docxtemplater().load('<w:p><w:r><w:br w:type="page"/></w:r></w:p>');
            mergedDoc.resolveData(pageBreak.getFullText());
        }

        const mergedContent = mergedDoc.getZip().generate({ type: 'nodebuffer' });

        // Save the merged document
        const mergedFileName = 'merged_document.docx';
        fs.writeFileSync(mergedFileName, mergedContent);

        console.log('Merged document saved successfully:', mergedFileName);
    } catch (error) {
        console.log("Error:", error);
    }
})();






import React, { Component } from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';
import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: 'shift + tab',
                focusNext: 'tab'
            }
        });

        this.tbName = new InputTextView(this.props.locale);
        this.tbName.placeholder = this.props.locale.t('Bookmark Name');
        this.saveButtonView = this._createButton(this.props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
        this.saveButtonView.type = this.props.locale.t('submit');
        this.cancelButtonView = this._createButton(this.props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

        this.tbName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-edit-tbName']
            }
        });

        this.setTemplate({
            tag: 'form',

            attributes: {
                class: ['ck-bookmark-edit'],
                tabIndex: '-1'
            },

            children: [
                this.tbName,
                this.saveButtonView,
                this.cancelButtonView
            ]
        });
    }

    componentDidMount() {
        super.componentDidMount();

        submitHandler({
            view: this
        });

        const childViews = [
            this.tbName,
            this.saveButtonView,
            this.cancelButtonView
        ];

        childViews.forEach(v => {
            this._focusables.add(v);
            this.focusTracker.add(v.element);
        });

        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [
                    className
                ]
            }
        });

        if (eventName) {
            button.delegate('execute').to(this, eventName);
        }

        return button;
    }

    render() {
        return (
            <form className="ck-bookmark-edit" tabIndex="-1">
                {this.tbName}
                {this.saveButtonView}
                {this.cancelButtonView}
            </form>
        );
    }
}

export default EditPopup;






















import React, { Component } from 'react';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import LabelView from '@ckeditor/ckeditor5-ui/src/label/labelview';
import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';

import pencilIcon from '@ckeditor/ckeditor5-core/theme/icons/pencil.svg';
import deleteIcon from '../../theme/icons/delete.svg';

class ViewPopup extends Component {
    constructor(props) {
        super(props);

        this.keystrokes = new KeystrokeHandler();

        this.lblName = new LabelView(this.props.locale);
        this.editButtonView = this._createButton(this.props.locale.t('Edit'), pencilIcon, 'ck-bookmark-view-btnEdit', 'edit');
        this.deleteButtonView = this._createButton(this.props.locale.t('Delete'), deleteIcon, 'ck-bookmark-view-btnDelete', 'delete');

        this.lblName.extendTemplate({
            attributes: {
                class: ['ck-bookmark-view-lblName']
            }
        });
    }

    componentDidMount() {
        this.keystrokes.listenTo(this.element);
    }

    _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.props.locale);

        button.set({
            label,
            icon,
            tooltip: true
        });

        button.extendTemplate({
            attributes: {
                class: [className]
            }
        });

        button.delegate('execute').to(this, eventName);

        return button;
    }

    render() {
        return (
            <div className="ck-bookmark-view">
                {this.lblName.render()}
                {this.editButtonView.render()}
                {this.deleteButtonView.render()}
            </div>
        );
    }
}

export default ViewPopup;


















import React from 'react';
import Plugin from '@ckeditor/ckeditor5-core/src/plugin';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';
import ClickObserver from '@ckeditor/ckeditor5-engine/src/view/observer/clickobserver';
import ContextualBalloon from '@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon';
import clickOutsideHandler from '@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler';
import ViewPopup from './ui/viewpopup';
import EditPopup from './ui/editpopup';
import bookmarkIcon from '../theme/icons/bookmark.svg';

class BookmarkUI extends Plugin {
    componentDidMount() {
        const editor = this.props.editor;
        const t = editor.t;

        editor.ui.componentFactory.add('bookmark', locale => {
            const btn = new ButtonView(locale);
            btn.set({
                label: t('Bookmark'),
                withText: false,
                tooltip: true,
                icon: bookmarkIcon
            });

            const bookmarkCommand = editor.commands.get('insertBookmark');
            btn.bind('isEnabled').to(bookmarkCommand, 'isEnabled');
            btn.bind('isOn').to(bookmarkCommand, 'isBookmark');

            this.listenTo(btn, 'execute', () => {
                editor.execute('insertBookmark');
                this._showUI();
            });

            return btn;
        });

        this._balloon = editor.plugins.get(ContextualBalloon);

        this._editPopup = this._createEditPopup();
        this._viewPopup = this._createViewPopup();

        editor.editing.view.addObserver(ClickObserver);
        this._enableUserBalloonInteractions();
    }

    _createEditPopup() {
        const editor = this.props.editor;
        const editPopup = new EditPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        editPopup.tbName.bind('value').to(command, 'value');

        editPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        this.listenTo(editPopup, 'submit', () => {
            const bookmarkName = editPopup.tbName.element.value;
            editor.execute('insertBookmark', bookmarkName);
            this._hideUI();
        });

        this.listenTo(editPopup, 'cancel', () => {
            this._hideUI();
        });

        return editPopup;
    }

    _createViewPopup() {
        const editor = this.props.editor;
        const viewPopup = new ViewPopup(editor.locale);

        const command = editor.commands.get('insertBookmark');
        viewPopup.lblName.bind('text').to(command, 'value');

        this.listenTo(viewPopup, 'edit', () => {
            this._balloon.remove(this._viewPopup);
            this._balloon.add({
                view: this._editPopup,
                position: this._getBalloonPositionData()
            });

            this._editPopup.tbName.select();
        });

        this.listenTo(viewPopup, 'delete', () => {
            this.editor.execute('deleteBookmark');
            this._hideUI();
        });

        viewPopup.keystrokes.set('Esc', (data, cancel) => {
            this._hideUI();
            cancel();
        });

        return viewPopup;
    }

    _enableUserBalloonInteractions() {
        const viewDocument = this.props.editor.editing.view.document;

        this.listenTo(viewDocument, 'click', () => {
            const elmBookmark = this._getSelectedBookmarkElement();
            if (elmBookmark) {
                this._showUI();
            }
        });

        clickOutsideHandler({
            emitter: this._editPopup,
            activator: () => this._balloon.visible
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            import React from 'react';
import View from '@ckeditor/ckeditor5-ui/src/view';
import ButtonView from '@ckeditor/ckeditor5-ui/src/button/buttonview';

import ViewCollection from '@ckeditor/ckeditor5-ui/src/viewcollection';
import InputTextView from '@ckeditor/ckeditor5-ui/src/inputtext/inputtextview';
import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';

import KeystrokeHandler from '@ckeditor/ckeditor5-utils/src/keystrokehandler';
import FocusTracker from '@ckeditor/ckeditor5-utils/src/focustracker';
import FocusCycler from '@ckeditor/ckeditor5-ui/src/focuscycler';

import checkIcon from '@ckeditor/ckeditor5-core/theme/icons/check.svg';
import cancelIcon from '@ckeditor/ckeditor5-core/theme/icons/cancel.svg';

class EditPopup extends React.Component {
  constructor(props) {
    super(props);

    this.keystrokes = new KeystrokeHandler();

    this.focusTracker = new FocusTracker();
    this._focusables = new ViewCollection();
    this._focusCycler = new FocusCycler({
      focusables: this._focusables,
      focusTracker: this.focusTracker,
      keystrokeHandler: this.keystrokes,
      actions: {
        focusPrevious: 'shift + tab',
        focusNext: 'tab'
      }
    });

    this.tbName = new InputTextView(props.locale);
    this.tbName.placeholder = props.locale.t('Bookmark Name');
    this.saveButtonView = this._createButton(props.locale.t('Save'), checkIcon, 'ck-bookmark-edit-btnSave');
    this.saveButtonView.type = props.locale.t('submit');
    this.cancelButtonView = this._createButton(props.locale.t('Cancel'), cancelIcon, 'ck-bookmark-edit-btnCancel', 'cancel');

    this.tbName.extendTemplate({
      attributes: {
        class: ['ck-bookmark-edit-tbName']
      }
    });

    this.setTemplate({
      tag: 'form',

      attributes: {
        class: ['ck-bookmark-edit'],
        tabindex: '-1'
      },

      children: [
        this.tbName,
        this.saveButtonView,
        this.cancelButtonView
      ]
    });
  }

  render() {
    super.render();

    submitHandler({
      view: this
    });

    const childViews = [
      this.tbName,
      this.saveButtonView,
      this.cancelButtonView
    ];

    childViews.forEach(v => {
      this._focusables.add(v);
      this.focusTracker.add(v.element);
    });

    this.keystrokes.listenTo(this.element);
  }

  _createButton(label, icon, className, eventName) {
    const button = new ButtonView(this.props.locale);

    button.set({
      label,
      icon,
      tooltip: true
    });

    button.extendTemplate({
      attributes: {
        class: [
          className
        ]
      }
    });

    if (eventName) {
      button.delegate('execute').to(this, eventName);
    }

    return button;
  }
}

export default EditPopup;


